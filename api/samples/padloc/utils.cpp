/**
 * \file utils.cpp
 * \brief Library Manipulation API Sample, part of the Padloc project.
 * Utilitary source file, containing various functions for modes and log levels. 
 *
 * This file gathers utilitary functions used throughout the program, the
 * main parsing function and the log level parts.
 * 
 * This file contains the main command line parsing function, and
 * calls the parser of plugins (currently 2 : symbol analysis and backend 
 * analysis) and the utilitary one.
 * 
 * \author Brasseur Dylan, Teaudors MickaÃ«l, Valeri Yoann
 * \date 2019
 * \copyright Interflop 
 */

#include <iostream>
#include <algorithm>
#include <cctype>

#include "dr_api.h"

#include "utils.hpp"

#include "symbol_config.hpp"
#include "analyse.hpp"

/**
 * Header string for files used by the symbol plugin.
 */
static const char *PLC_SYMBOL_FILE_HEADER =
    "# This file has been generated by the Padloc sample to hold symbols used by the given program.\n"
    "# Only the symbols using floating point operations that we may instrument are listed\n"
    "# You can use it as a whitelist, blacklist, and modify it as you wish.\n"
    "# Comments start with the character \'#\'.\n"
    "# Each line of this file holds a symbol in the following format : \n"
    "#\n"
    "#\t\t\tmodule!symbol\n"
    "#\n"
    "# Here, a module can designate an executable, a library file... as per DynamoRIO's standards.\n"
    "# A name alone (without a \'!\') designates the whole module\n"
    "# Note that the whole modules listed here don't mean the program used the whole module, but rather that that module was used\n"
    "#\n";

/**
 * Helper string, contains all the options available, along with how
 * to actually use the client.
 */
static const char* PLC_HELP_STRING =
    "Padloc sample for DynamoRIO : replaces the floating point operations with their equivalent in Monte Carlo Arithmetics [Parker et al. 2000]\n" 
    "Usage : drrun [drrun options] -c libpadloc.so [Padloc options] -- app/to/instrument [program arguments]\n"
    "Padloc options :\n"
    "\t -d\n\t --debug\n\t\tSets the client to debug mode\n\n"
    "\t -h\n\t --help\n\t\tDisplays the current help, stops the program\n\n"
    "\t -l [integer]\n\t --loglevel [integer]\n\t\tSets the loglevel to the given integer, with 1 being debug mode, 2 being warning mode and 3 being error mode\n\n"
    "\t -n\n\t --no-lookup\n\t\t(Default) Disables the lookup for the symbols, instruments every floating operation\n\n"
    "\t -w [filename]\n\t --whitelist [filename]\n\t\tInstruments only the symbols present in the given file\n\n"
    "\t -b [filename]\n\t --blacklist [filename]\n\t\tDisable the instrumentation for the symbols present in the given file\n\n"
    "\t -g [filename]\n\t --generate [filename]\n\tGenerates the list of symbols in the given program and writes it to the given file, doesn't instrument anything\n\n"
    "\t -aa [filename]\n\t --analyse_abort [filename]\n\tAnalyse the registers used by the backend, dump them into the given file, and stop execution\n\n"
    "\t -af [filename]\n\t --analyse_file [filename]\n\tRead the values in the given file, and use those values to save particular registers\n\n"
    "\t -ar\n\t --analyse_run\n\tAnalyse the backend normally and run the program afterwards\n\n"
    "\n";

/**
 * Integer representing the log_levels, which work as follow :
 *  - level 0, no display from the client;
 *  - level 1, debug mode, display minimal information about
 *  the instrumented instructions and registers used by the backend;
 *  - level 2, warning mode, display important information regarding
 *  the behaviour of the code;
 *  - level 3, error mode, display critical errors and problems encountered
 *  in the program.
 */
static int log_level = 0;

/**
 * Integer representing the amount of parsers that didn't recognize a command
 * line option. When all the parsers didn't recognize a command line option,
 * that means this is an unknown command option, and an error is generated.
 */
static int error_count = 0;

/**
 * Client mode as defined by the enum in "utils.hpp". This characterizes the
 * mode in which the symbol analysis plugin behaves, according to rules
 * regarding blacklist, whitelist and such. 
 * The default mode is PLC_SYMBOL_DEFAULT, meaning that no particular symbol
 * analysis is needed.
 */
static padloc_symbol_mode_t padloc_symbols_mode = PLC_SYMBOL_DEFAULT;

/**
 * Analysis mode as defined by the enum in "utils.hpp". This characterizes the
 * mode in which the backend analysis plugin behaves. Only two modes are
 * currently implement, regarding the need of backend analysis or not.
 * The default mode is PLC_ANALYSE_NEEDED, meaning that the backend has to be
 * analysed. 
 */
static padloc_analyse_mode_t padloc_analyse_mode = PLC_ANALYSE_NEEDED;

void set_log_level(int level){
    log_level = level;
}

int get_log_level(){
    return log_level;
}

void set_symbol_mode(padloc_symbol_mode_t mode){
    padloc_symbols_mode = mode;
}

padloc_symbol_mode_t get_symbol_mode(){
    return padloc_symbols_mode;
}

void set_analyse_mode(padloc_analyse_mode_t mode){
    padloc_analyse_mode = mode;
}

padloc_analyse_mode_t get_analyse_mode(){
    return padloc_analyse_mode;
}

void print_help(){
    dr_printf(PLC_HELP_STRING);
}

void write_to_file_symbol_file_header(std::ofstream &output){
    output << PLC_SYMBOL_FILE_HEADER;
}

void inc_error(){
    error_count += 1;
}

/**
 * \brief Reset the error counter to 0
 */
static void reset_error_count(){
    error_count = 0;
}

bool is_number(const std::string &str){
    return !str.empty() && std::find_if(str.begin(),
                                      str.end(), [](char c){ return !std::isdigit(c); }) == str.end();
}

/**
 * \brief Utilitaries argument parser
 * \details Parser for the utilitaries functionnalities. The possible options
 * are currently :
 *      - debug, with "--debug" or "-d", which sets the log level at 1 if not
 *      already greater than 1;
 *      - help, with "--help" or "-h", which display the help string and stop
 *      the execution of the program;
 *      - loglevel, with "--loglevel" or "-l", which sets the log level with
 *      the following integer, which is between 0 and 3.
 * 
 * \param arg The current argument as string
 * \param i The index of the current argument, given as pointer to be modified
 * if necessary when checking for an option with special parameters
 * \param argc The length of the command line
 * \param argv The list of arguments in the command line
 * \return True if the execution of the program must be stopped, else false
 */
static bool utils_argument_parser(const std::string arg, int *i, 
    int argc, const char* argv[]){
    if(arg == "--debug" || arg == "-d"){
        /*
         * The debug option was detected, so if the loglevel is 0, set it to 1.
         */
        if(get_log_level() < 1){
            set_log_level(1);
        }
    }else if(arg == "--help" || arg == "-h"){
        /*
         * The help option was detected, so print the help string and
         * return true.
         */
        print_help();
        return true;
    }else if(arg == "--loglevel" || arg == "-l"){
        *i += 1;
        if(*i < argc){
            /*
             * The loglevel option was detected, so we get the next command
             * line string, verify it is a number, and if so, set the log level
             * to that number, if possible and relevant.
             */
            std::string string_level(argv[*i]);
            if(!is_number(string_level)){
                dr_fprintf(STDERR, 
                        "LOGLEVEL FAILURE : Couldn't change the loglevel to \"%s\"\n", 
                        argv[*i]);
                set_symbol_mode(PLC_SYMBOL_HELP);
                return true;
            }
            int level = std::stoi(string_level);
            if(0 <= level && level <= 3 && get_log_level() < level){
                set_log_level(level);
            }
        }else{
            dr_fprintf(STDERR, 
                "NOT ENOUGH ARGUMENTS : Lacking the loglevel associated with -l\n");
            set_symbol_mode(PLC_SYMBOL_HELP);
            return true;
        }
    }else{
        /* If the argument is not one we know, increment the error counter */
        inc_error();
    }
    return false;
}

bool arguments_parser(int argc, const char *argv[]){
    for(int i = 1; i < argc; ++i){
        /* Reset the error count */
        reset_error_count();
        std::string arg(argv[i]);
        /*
         * We first call the utilitary parser, then the symbol parser
         * and finally, the backend analysis parser.
         * If all the parser return false, and error_count is
         * equal to UNKNOWN_ARGUMENT, the command line option is
         * unknown, so print an error and return true.
         */
        if(utils_argument_parser(arg, &i, argc, argv)){
            return true;
        }else if(symbol_argument_parser(arg, &i, argc, argv)){
            return true;
        }else if(analyse_argument_parser(arg, &i, argc, argv)){
            return true;
        }else if(error_count == UNKNOWN_ARGUMENT){
            dr_fprintf(STDERR, "Unknown command line option\n");
            return true;
        }
    }
    /*
     * When all the command line options have been checked, we call the manager
     * of each other part of the code, and they will do what's necessary
     * according to the state of the program.
     */
    symbol_client_mode_manager();
    analyse_mode_manager();
    return false;
}